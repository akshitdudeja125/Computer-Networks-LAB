{
  "Folder transfer TCP": {
    "prefix": "fttcp",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <pthread.h>",
      "#include <dirent.h>",
      "#include <sys/stat.h>",
      "",
      "#define PORT 8085",
      "#define MAX_CONN 10",
      "#define MAX_FILENAME_LEN 256",
      "#define MAX_BUFFER_SIZE 1024",
      "#define IP \"10.10.88.233\"",
      "#define RECEIVED_FILES_FOLDER \"received_files\"",
      "",
      "void *handle_connection(void *sock_fd)",
      "{",
      "    int client_socket = *((int *)sock_fd);",
      "    char filename[MAX_FILENAME_LEN];",
      "    ssize_t bytes_received;",
      "",
      "    DIR *dir;",
      "",
      "    if ((dir = opendir(RECEIVED_FILES_FOLDER)) == NULL)",
      "    {",
      "        // mkdir(RECEIVED_FILES_FOLDER, 0777);",
      "        if (mkdir(RECEIVED_FILES_FOLDER, 0777) == -1)",
      "        {",
      "            perror(\"Failed to open directory\");",
      "            close(client_socket);",
      "            pthread_exit(NULL);",
      "        }",
      "    }",
      "    else",
      "    {",
      "        closedir(dir);",
      "    }",
      "",
      "    // Receive filename",
      "    if ((bytes_received = recv(client_socket, filename, MAX_FILENAME_LEN, 0)) == -1)",
      "    {",
      "        perror(\"Receive failed\");",
      "        close(client_socket);",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    filename[bytes_received] = '\\0';",
      "    printf(\"Received file: %s\\n\", filename);",
      "",
      "    char filePath[MAX_BUFFER_SIZE];",
      "    snprintf(filePath, MAX_BUFFER_SIZE, \"%s/%s\", RECEIVED_FILES_FOLDER, filename);",
      "",
      "    printf(\"File path: %s\\n\", filePath);",
      "",
      "    // Open file",
      "    FILE *file = fopen(filePath, \"wb\");",
      "    if (!file)",
      "    {",
      "        perror(\"File open failed\");",
      "        close(client_socket);",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    // Receive file data and write to file",
      "    ssize_t bytes_read;",
      "    while (1)",
      "    {",
      "        char buffer[MAX_BUFFER_SIZE];",
      "        bytes_read = recv(client_socket, buffer, sizeof(buffer), 0);",
      "        buffer[bytes_read] = '\\0';",
      "",
      "        if (bytes_read == 0)",
      "        {",
      "            break;",
      "        }",
      "",
      "        if (bytes_read < 0)",
      "        {",
      "            perror(\"Receive failed\");",
      "            close(client_socket);",
      "            fclose(file);",
      "            pthread_exit(NULL);",
      "        }",
      "",
      "        // printf(\"Received bytes: %ld\\n\", bytes_read);",
      "        // printf(\"Received: %s\\n\", buffer);",
      "",
      "        if (fwrite(buffer, 1, bytes_read, file) != bytes_read)",
      "        {",
      "            perror(\"File write failed\");",
      "            close(client_socket);",
      "            fclose(file);",
      "            pthread_exit(NULL);",
      "        }",
      "    }",
      "",
      "    // Close file and connection",
      "    fclose(file);",
      "    close(client_socket);",
      "    printf(\"File received successfully: %s\\n\", filename);",
      "",
      "    pthread_exit(NULL);",
      "}",
      "",
      "int main()",
      "{",
      "    int server_socket, client_socket;",
      "    struct sockaddr_in server_addr, client_addr;",
      "    socklen_t addr_len = sizeof(client_addr);",
      "",
      "    // Create server socket",
      "    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1)",
      "    {",
      "        perror(\"Socket creation failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Set server address parameters",
      "    server_addr.sin_family = AF_INET;",
      "    // server_addr.sin_addr.s_addr = INADDR_ANY;",
      "    if (inet_pton(AF_INET, IP, &(server_addr.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "    server_addr.sin_port = htons(PORT);",
      "",
      "    // Bind socket to address",
      "    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)",
      "    {",
      "        perror(\"Bind failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Listen for connections",
      "    if (listen(server_socket, MAX_CONN) == -1)",
      "    {",
      "        perror(\"Listen failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    printf(\"Server listening on port %d...\\n\", PORT);",
      "",
      "    // Accept connections and handle them in separate threads",
      "    while (1)",
      "    {",
      "        if ((client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &addr_len)) == -1)",
      "        {",
      "            perror(\"Accept failed\");",
      "            exit(EXIT_FAILURE);",
      "        }",
      "        printf(\"Connection accepted from %s:%d\\n\", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));",
      "",
      "        pthread_t thread_id;",
      "        int *client_socket_ptr = (int *)malloc(sizeof(int));",
      "        if (client_socket_ptr == NULL)",
      "        {",
      "            perror(\"Error allocating memory\");",
      "            close(client_socket);",
      "            continue;",
      "        }",
      "        *client_socket_ptr = client_socket;",
      "        if (pthread_create(&thread_id, NULL, handle_connection, (void *)client_socket_ptr) != 0)",
      "        {",
      "            perror(\"Error creating thread\");",
      "            close(client_socket);",
      "            free(client_socket_ptr);",
      "            continue;",
      "        }",
      "",
      "        // Detach thread",
      "        pthread_detach(thread_id);",
      "    }",
      "",
      "    close(server_socket);",
      "    return 0;",
      "}"
    ],
    "description": "Folder transfer TCP"
  },
  "Folder transfer tcp client": {
    "prefix": "fttcpc",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <dirent.h>",
      "#include <pthread.h>",
      "#include <sys/time.h>",
      "",
      "#define PORT 8085",
      "#define MAX_FILENAME_LEN 256",
      "#define MAX_BUFFER_SIZE 1024",
      "#define IP \"10.10.150.197\"",
      "#define FOLDER_PATH \"client_files\"",
      "long max_file_size = 0;",
      "",
      "void *send_file(void *filename)",
      "{",
      "    printf(\"Sending file: %s\\n\", (char *)filename);",
      "    char *file = (char *)filename;",
      "    int sock_fd;",
      "    struct sockaddr_in server_addr;",
      "    ssize_t bytes_sent;",
      "",
      "    // Connect to server",
      "    if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1)",
      "    {",
      "        perror(\"Socket creation failed\");",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    server_addr.sin_family = AF_INET;",
      "    server_addr.sin_port = htons(PORT);",
      "    if (inet_pton(AF_INET, IP, &(server_addr.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    if (connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)",
      "    {",
      "        perror(\"Connection failed\");",
      "        close(sock_fd);",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    // Send filename",
      "    if (send(sock_fd, file, MAX_FILENAME_LEN, 0) == -1)",
      "    {",
      "        perror(\"Send failed\");",
      "        close(sock_fd);",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    // Open file",
      "    char filePath[MAX_BUFFER_SIZE];",
      "    snprintf(filePath, MAX_BUFFER_SIZE, \"%s/%s\", FOLDER_PATH, file);",
      "",
      "    FILE *fptr = fopen(filePath, \"rb\");",
      "    if (!fptr)",
      "    {",
      "        perror(\"File open failed\");",
      "        close(sock_fd);",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    // Send file data",
      "    long file_size_temp = 0;",
      "    while (1)",
      "    {",
      "        char buffer[MAX_BUFFER_SIZE];",
      "        size_t bytes_read = fread(buffer, 1, sizeof(buffer), fptr);",
      "        if (bytes_read < 0)",
      "        {",
      "            perror(\"File read failed\");",
      "            fclose(fptr);",
      "            close(sock_fd);",
      "            pthread_exit(NULL);",
      "        }",
      "        if (bytes_read == 0)",
      "        {",
      "            break;",
      "        }",
      "        if (send(sock_fd, buffer, sizeof(buffer), 0) == -1)",
      "        {",
      "            perror(\"Send failed\");",
      "            fclose(fptr);",
      "            close(sock_fd);",
      "            pthread_exit(NULL);",
      "        }",
      "        file_size_temp += bytes_read;",
      "    }",
      "",
      "    if (max_file_size < file_size_temp)",
      "        max_file_size = file_size_temp;",
      "",
      "    // Close file and connection",
      "    fclose(fptr);",
      "    close(sock_fd);",
      "",
      "    printf(\"File sent successfully: %s\\n\", file);",
      "",
      "    pthread_exit(NULL);",
      "}",
      "",
      "int main()",
      "{",
      "    DIR *dir;",
      "    struct dirent *entry;",
      "",
      "    // Start time measurement",
      "    struct timeval start, end;",
      "    gettimeofday(&start, NULL);",
      "",
      "    // Open directory",
      "    if ((dir = opendir(FOLDER_PATH)) == NULL)",
      "    {",
      "        perror(\"Failed to open directory\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    int num_files = 0;",
      "    // Count number of files",
      "    while ((entry = readdir(dir)) != NULL)",
      "    {",
      "        if (entry->d_type == DT_REG)",
      "            num_files++;",
      "    }",
      "",
      "    printf(\"Number of files to send: %d\\n\", num_files);",
      "",
      "    // Send files in parallel",
      "    pthread_t threads[num_files];",
      "    int i = 0;",
      "",
      "    rewinddir(dir);",
      "",
      "    // Create threads to send files",
      "    while ((entry = readdir(dir)) != NULL)",
      "    {",
      "        if (entry->d_type == DT_REG)",
      "        {",
      "            char *filename = entry->d_name;",
      "            pthread_create(&threads[i], NULL, send_file, (void *)filename);",
      "            i++;",
      "        }",
      "    }",
      "",
      "    closedir(dir);",
      "",
      "    // Join threads",
      "    for (int j = 0; j < num_files; j++)",
      "    {",
      "        pthread_join(threads[j], NULL);",
      "    }",
      "",
      "    // End time measurement",
      "    gettimeofday(&end, NULL);",
      "    double time_taken = (end.tv_sec - start.tv_sec) * 1e6;",
      "    time_taken = (time_taken + (end.tv_usec - start.tv_usec)) * 1e-6;",
      "",
      "    printf(\"Time taken to send all files: %.6f seconds\\n\", time_taken);",
      "    printf(\"Max size of all files: %ld bytes\\n\", max_file_size);",
      "",
      "    return 0;",
      "}"
    ],
    "description": "Folder transfer tcp client"
  },
  "Perform Get/Post Requst": {
    "prefix": "getpostreq",
    "body": [
      "#include <stdio.h>",
      "#include <stdbool.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <netdb.h>",
      "",
      "#define PORT 80",
      "#define BUFFER_SIZE 1024",
      "#define FILENAME \"response.html\"",
      "#define HEADER_FILENAME \"header.txt\"",
      "",
      "void receive_http_response(int client_socket)",
      "{",
      "    char buffer[BUFFER_SIZE];",
      "    ssize_t bytes_received;",
      "    bool headers_done = false;",
      "",
      "    FILE *file = fopen(FILENAME, \"wb\");",
      "    if (file == NULL)",
      "    {",
      "        perror(\"Error opening file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    FILE *header_file = fopen(HEADER_FILENAME, \"wb\");",
      "    if (header_file == NULL)",
      "    {",
      "        perror(\"Error opening header file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    while ((bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0)) > 0)",
      "    {",
      "        if (!headers_done)",
      "        {",
      "            char *end_of_headers = strstr(buffer, \"\\r\\n\\r\\n\");",
      "            if (end_of_headers != NULL)",
      "            {",
      "                fwrite(buffer, 1, end_of_headers - buffer + 4, header_file);",
      "                fwrite(end_of_headers + 4, 1, bytes_received - (end_of_headers - buffer) - 4, file);",
      "                headers_done = true;",
      "            }",
      "            else",
      "                fwrite(buffer, 1, bytes_received, header_file);",
      "        }",
      "        else",
      "            fwrite(buffer, 1, bytes_received, file);",
      "    }",
      "",
      "    fclose(file);",
      "}",
      "",
      "void perform_get_request(int client_socket, const char *host, const char *path)",
      "{",
      "    char request[BUFFER_SIZE];",
      "",
      "    snprintf(request, BUFFER_SIZE, \"GET %s HTTP/1.1\\r\\nHost: %s\\r\\nConnection: close\\r\\n\\r\\n\", path, host);",
      "",
      "    ssize_t bytes_sent = send(client_socket, request, strlen(request), 0);",
      "    if (bytes_sent < 0)",
      "    {",
      "        perror(\"Error sending request\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    receive_http_response(client_socket);",
      "}",
      "",
      "void perform_post_request(int client_socket, const char *host, const char *path, const char *data)",
      "{",
      "    size_t data_length = strlen(data);",
      "",
      "    char request[BUFFER_SIZE];",
      "    snprintf(request, BUFFER_SIZE, \"POST %s HTTP/1.1\\r\\nHost: %s\\r\\nContent-Length: %zu\\r\\nConnection: close\\r\\n\\r\\n%s\", path, host, data_length, data);",
      "",
      "    ssize_t bytes_sent = send(client_socket, request, strlen(request), 0);",
      "    if (bytes_sent < 0)",
      "    {",
      "        perror(\"Error sending request\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    receive_http_response(client_socket);",
      "}",
      "",
      "int main()",
      "{",
      "    int client_socket;",
      "    struct sockaddr_in server_addr;",
      "    const char *host = \"www.google.com\";",
      "    const char *path = \"/index.html\";",
      "    // const char *post_data = \"key1=value1&key2=value2\";",
      "    const char *post_data = \"query=example\";",
      "",
      "    client_socket = socket(AF_INET, SOCK_STREAM, 0);",
      "    if (client_socket == -1)",
      "    {",
      "        perror(\"Error creating client socket\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    struct hostent *server;",
      "    server = gethostbyname(host);",
      "    if (server == NULL)",
      "        herror(\"No such Host\");",
      "",
      "    server_addr.sin_family = AF_INET;",
      "    memcpy(&server_addr.sin_addr, server->h_addr_list[0], server->h_length);",
      "    server_addr.sin_port = htons(PORT);",
      "",
      "    if (connect(client_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1)",
      "    {",
      "        perror(\"Error connecting to server\");",
      "        close(client_socket);",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Perform GET request",
      "    // printf(\"Performing GET request...\\n\");",
      "    // perform_get_request(client_socket, host, path);",
      "",
      "    // Perform POST request",
      "    printf(\"\\nPerforming POST request...\\n\");",
      "    perform_post_request(client_socket, host, path, post_data);",
      "",
      "    close(client_socket);",
      "",
      "    return 0;",
      "}",
      ""
    ],
    "description": "Perform Get/Post Requst"
  },
  "Open File from browser get req": {
    "prefix": "getReq",
    "body": [
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <arpa/inet.h>",
      "#include <ctype.h>",
      "#include <dirent.h>",
      "#include <errno.h>",
      "#include <fcntl.h>",
      "#include <netinet/in.h>",
      "#include <pthread.h>",
      "#include <regex.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <sys/socket.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "",
      "#define PORT 3005",
      "#define BUFFER_SIZE 1e9",
      "#define IP \"127.0.0.1\"",
      "",
      "const char *extractFileExtension(const char *file_name)",
      "{",
      "    const char *dot = strrchr(file_name, '.');",
      "    if (!dot || dot == file_name)",
      "        return \"\";",
      "    return dot + 1;",
      "}",
      "",
      "const char *generateMimeType(const char *file_ext)",
      "{",
      "    if (strcasecmp(file_ext, \"html\") == 0 || strcasecmp(file_ext, \"htm\") == 0)",
      "        return \"text/html\";",
      "    else if (strcasecmp(file_ext, \"txt\") == 0)",
      "        return \"text/plain\";",
      "    else if (strcasecmp(file_ext, \"jpg\") == 0 || strcasecmp(file_ext, \"jpeg\") == 0)",
      "        return \"image/jpeg\";",
      "    else if (strcasecmp(file_ext, \"png\") == 0)",
      "        return \"image/png\";",
      "    else",
      "        return \"application/octet-stream\";",
      "}",
      "",
      "char *decodeURL(const char *src)",
      "{",
      "    size_t src_len = strlen(src);",
      "    char *decoded = (char *)malloc(src_len + 1);",
      "    size_t decoded_len = 0;",
      "",
      "    for (size_t i = 0; i < src_len; i++)",
      "    {",
      "        if (src[i] == '%' && i + 2 < src_len)",
      "        {",
      "            char hex_val_str[3] = {src[i + 1], src[i + 2], '\\0'};",
      "            int hex_val = (int)strtol(hex_val_str, NULL, 16);",
      "            decoded[decoded_len++] = (char)hex_val;",
      "            i += 2;",
      "        }",
      "        else",
      "            decoded[decoded_len++] = src[i];",
      "    }",
      "",
      "    decoded[decoded_len] = '\\0';",
      "    return decoded;",
      "}",
      "",
      "void generateResponse(const char *file_name, const char *file_ext, char *response, size_t *response_len)",
      "{",
      "    const char *mime_type = generateMimeType(file_ext);",
      "    char *header = (char *)malloc(BUFFER_SIZE * sizeof(char));",
      "    ",
      "    snprintf(header, BUFFER_SIZE, \"HTTP/1.1 200 OK\\r\\nContent-Type: %s\\r\\n\\r\\n\", mime_type);",
      "",
      "    int file_fd = open(file_name, O_RDONLY);",
      "    if (file_fd == -1)",
      "    {",
      "        snprintf(response, BUFFER_SIZE, \"HTTP/1.1 404 Not Found\\r\\nContent-Type: text/plain\\r\\n\\r\\n404 Not Found\");",
      "        *response_len = strlen(response);",
      "        return;",
      "    }",
      "",
      "    struct stat file_stat;",
      "    fstat(file_fd, &file_stat);",
      "    off_t file_size = file_stat.st_size;",
      "",
      "    *response_len = 0;",
      "    memcpy(response, header, strlen(header));",
      "    *response_len += strlen(header);",
      "",
      "    ssize_t bytes_read;",
      "    while ((bytes_read = read(file_fd, response + *response_len, BUFFER_SIZE - *response_len)) > 0)",
      "        *response_len += bytes_read;",
      "",
      "    free(header);",
      "    close(file_fd);",
      "}",
      "",
      "void *handleClient(int client_socket)",
      "{",
      "    char *buffer = (char *)malloc(BUFFER_SIZE * sizeof(char));",
      "",
      "    ssize_t bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);",
      "    printf(\"client_socket: %d\\n\", client_socket);",
      "    printf(\"Buffer: %s\\n\", buffer);",
      "    // GET /index.html HTTP/1.1",
      "    if (bytes_received > 0)",
      "    {",
      "        char *get_ptr = strstr(buffer, \"GET /\");",
      "        if (get_ptr != NULL)",
      "        {",
      "            char *http_ptr = strstr(get_ptr, \" HTTP/1\");",
      "            if (http_ptr != NULL)",
      "            {",
      "                *http_ptr = '\\0';",
      "",
      "                char *file_name = decodeURL(get_ptr + 5);",
      "",
      "                char file_ext[32];",
      "                strcpy(file_ext, extractFileExtension(file_name));",
      "",
      "                char *response = (char *)malloc(BUFFER_SIZE * sizeof(char));",
      "                size_t response_len;",
      "                generateResponse(file_name, file_ext, response, &response_len);",
      "",
      "                send(client_socket, response, response_len, 0);",
      "",
      "                free(response);",
      "                free(file_name);",
      "            }",
      "        }",
      "    }",
      "    close(client_socket);",
      "    free(buffer);",
      "    return NULL;",
      "}",
      "",
      "int main()",
      "{",
      "    int server_socket;",
      "    struct sockaddr_in server_addr;",
      "",
      "    if ((server_socket = socket(AF_INET, SOCK_STREAM, 0)) < 0)",
      "    {",
      "        perror(\"socket failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    server_addr.sin_family = AF_INET;",
      "    // server_addr.sin_addr.s_addr = INADDR_ANY;",
      "    if (inet_pton(AF_INET, IP, &(server_addr.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "    server_addr.sin_port = htons(PORT);",
      "",
      "    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)",
      "    {",
      "        perror(\"bind failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    if (listen(server_socket, 10) < 0)",
      "    {",
      "        perror(\"listen failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    printf(\"Server listening on Port %d\\n\", PORT);",
      "",
      "    while (1)",
      "    {",
      "        struct sockaddr_in client_addr;",
      "        socklen_t client_addr_len = sizeof(client_addr);",
      "        int client_socket;",
      "",
      "        if ((client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_len)) < 0)",
      "        {",
      "            perror(\"Accept Failed\");",
      "            continue;",
      "        }",
      "",
      "        pid_t pid = fork();",
      "        if (pid < 0)",
      "        {",
      "            perror(\"Fork Failed\");",
      "            close(client_socket);",
      "            continue;",
      "        }",
      "        else if (pid == 0)",
      "        {",
      "            close(server_socket);",
      "            handleClient(client_socket);",
      "            exit(EXIT_SUCCESS);",
      "        }",
      "        else",
      "            close(client_socket);",
      "    }",
      "",
      "    close(server_socket);",
      "    return 0;",
      "}"
    ],
    "description": "Open File from browser get req"
  },
  "Go Back N server": {
    "prefix": "gbns",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdbool.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include \"../utils.h\"",
      "",
      "#define PORT 8080",
      "#define MAX_BUFFER_SIZE 1024",
      "#define N 1 // Receiver Window Size",
      "#define IP \"127.0.0.1\"",
      "#define TIMEOUT 5",
      "// #define N_lost 2 // Every N_lost Acknowledgement frame will be lost",
      "// #define N_delayed 4 // Every N_delayed Acknowledgement Frame will be delayed",
      "#define P 1.0                        // Probability with which Acknowledgement frame will be lost",
      "#define FILENAME \"received_file.txt\" // Name of the file to save on the server",
      "",
      "int main()",
      "{",
      "    srand(time(NULL));",
      "",
      "    int sockfd;",
      "    struct sockaddr_in serverAddress, clientAddress;",
      "    char buffer[MAX_BUFFER_SIZE];",
      "    socklen_t client_addr_size;",
      "",
      "    FILE *file;",
      "    ssize_t bytes_received;",
      "",
      "    file = fopen(FILENAME, \"wb\");",
      "    if (file == NULL)",
      "    {",
      "        perror(\"Error creating file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    int start = 0;",
      "    bool comp = false;",
      "    Frame frame_recv;",
      "    Frame frame_send;",
      "    Frame frames[N];",
      "",
      "    for (int i = 0; i < N; i++)",
      "    {",
      "        frames[i].packet.data[0] = '\\0';",
      "        frames[i % N].frame_kind = 0;",
      "    }",
      "",
      "    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)",
      "    {",
      "        perror(\"socket creation failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    memset(&serverAddress, '\\0', sizeof(serverAddress));",
      "    serverAddress.sin_family = AF_INET;",
      "    serverAddress.sin_port = htons(PORT);",
      "    // serverAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\");",
      "    if (inet_pton(AF_INET, IP, &(serverAddress.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    if (bind(sockfd, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0)",
      "    {",
      "        perror(\"Error binding socket\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    printf(\"[+]Server Started\\n\\n\");",
      "",
      "    client_addr_size = sizeof(clientAddress);",
      "",
      "    while (1)",
      "    {",
      "        int bytes_received = recvfrom(sockfd, &frame_recv, sizeof(Frame), 0, (struct sockaddr *)&clientAddress, &client_addr_size);",
      "",
      "        if (bytes_received < 0)",
      "        {",
      "            printf(\"[-]Error Receiving Frame\\n\");",
      "            exit(EXIT_FAILURE);",
      "        }",
      "        else if (bytes_received > 0)",
      "        {",
      "            if (frame_recv.frame_kind == 1)",
      "            {",
      "",
      "                if (frame_recv.sq_no == start)",
      "                {",
      "                    frames[frame_recv.sq_no % N] = frame_recv;",
      "",
      "                    int i;",
      "                    for (i = start; i < start + N; i++)",
      "                    {",
      "                        if (frames[i % N].packet.data[0] == '\\0')",
      "                        {",
      "                            break;",
      "                        }",
      "",
      "                        printf(\"[+]Frame %d Received:\\n\", frame_recv.sq_no);",
      "",
      "                        if (frame_recv.packet.data[0] == 'E' && frame_recv.packet.data[1] == 'O' && frame_recv.packet.data[2] == 'F')",
      "                        {",
      "                            printf(\"[+]File Transfer Complete\\n\");",
      "                            comp = true;",
      "                        }",
      "                        else if (fwrite(frames[i % N].packet.data, 1, MAX_BUFFER_SIZE, file) != MAX_BUFFER_SIZE)",
      "                        {",
      "                            perror(\"Error writing to file\");",
      "                            exit(EXIT_FAILURE);",
      "                        }",
      "",
      "                        frames[i % N].packet.data[0] = '\\0';",
      "                    }",
      "                    start = (comp) ? 0 : i;",
      "                    comp = false;",
      "",
      "                    frame_send.sq_no = i - 1;",
      "                }",
      "                else if (frame_recv.sq_no > start && frame_recv.sq_no < start + N)",
      "                {",
      "                    frames[frame_recv.sq_no % N] = frame_recv;",
      "                    printf(\"[-]Frame Out of Order\\n\");",
      "                    frame_send.sq_no = start - 1;",
      "                    frame_send.frame_kind = 0;",
      "                }",
      "                else",
      "                {",
      "                    if (frame_recv.sq_no < start)",
      "                        printf(\"[-]Frame Already Received\\n\");",
      "                    if (frame_recv.sq_no >= start + N)",
      "                        printf(\"[-]Frame Out of Order\\n\");",
      "                    frame_send.sq_no = start - 1;",
      "                    frame_send.frame_kind = 0;",
      "                }",
      "",
      "                double random_number = (double)rand() / RAND_MAX;",
      "",
      "                // if ((frame_id + 1) % N_delayed == 0)",
      "                //     sleep(TIMEOUT + 1);",
      "",
      "                if (random_number <= P)",
      "                // if ((frame_id + 1) % N_lost)",
      "                {",
      "                    sendto(sockfd, &frame_send, sizeof(Frame), 0, (struct sockaddr *)&clientAddress, client_addr_size);",
      "                    printf(\"[+]Ack %d Send\\n\", frame_send.sq_no);",
      "                }",
      "            }",
      "            else if (frame_recv.frame_kind == 0)",
      "            {",
      "                printf(\"[-]Why is Client sending Acknowledgement Frame???\\n\");",
      "            }",
      "            else",
      "            {",
      "                printf(\"[-]Invalid Frame Received\\n\");",
      "            }",
      "        }",
      "        else",
      "        {",
      "            printf(\"[-]Connection Closed!\\n\");",
      "            break;",
      "        }",
      "        printf(\"\\n\\n\");",
      "    }",
      "",
      "    fclose(file);",
      "    close(sockfd);",
      "    return 0;",
      "}"
    ],
    "description": "Go Back N server"
  },
  "Go Back N client select": {
    "prefix": "gbncs",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdbool.h>",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <sys/time.h>",
      "#include <sys/select.h>",
      "#include \"../utils.h\"",
      "",
      "#define PORT 8080",
      "#define MAX_BUFFER_SIZE 1024",
      "// #define N 3 // Sender Window Size",
      "#define IP \"127.0.0.1\"",
      "#define TIMEOUT_SEC 3  // Timeout in seconds",
      "#define TIMEOUT_USEC 0 // Timeout in microseconds",
      "// #define N_lost 5       // Every N_lost Data frame will be lost",
      "#define P 1.0                 // Probability with which Data frame will be lost",
      "#define FILENAME \"sample.txt\" // Name of the file to be sent",
      "",
      "int func(int N)",
      "{",
      "    srand(time(NULL));",
      "",
      "    int sockfd;",
      "    struct sockaddr_in serverAddress;",
      "    char buffer[MAX_BUFFER_SIZE];",
      "    socklen_t server_addr_size;",
      "",
      "    FILE *file;",
      "    ssize_t bytes_read;",
      "",
      "    file = fopen(FILENAME, \"rb\");",
      "    if (file == NULL)",
      "    {",
      "        perror(\"Error opening file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    int start = 0;",
      "    int next = start;",
      "    int count = 0;",
      "    Frame frame_recv;",
      "    Frame frames[N];",
      "",
      "    for (int i = 0; i < N; i++)",
      "    {",
      "        frames[i].packet.data[0] = '\\0';",
      "    }",
      "",
      "    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)",
      "    {",
      "        perror(\"socket creation failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    memset(&serverAddress, '\\0', sizeof(serverAddress));",
      "    serverAddress.sin_family = AF_INET;",
      "    serverAddress.sin_port = htons(PORT);",
      "    // serverAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\");",
      "    if (inet_pton(AF_INET, IP, &(serverAddress.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    server_addr_size = sizeof(serverAddress);",
      "",
      "    fseek(file, 0, SEEK_END);",
      "    int total_frames = (int)((double)ftell(file) / (double)MAX_BUFFER_SIZE) + ftell(file) % MAX_BUFFER_SIZE ? 2 : 1;",
      "    fseek(file, 0, SEEK_SET);",
      "",
      "    struct timeval start_time, end_time;",
      "    gettimeofday(&start_time, NULL);",
      "",
      "    while (1)",
      "    {",
      "        for (int i = next; i < start + N && start < total_frames; i++)",
      "        {",
      "            if (frames[i % N].packet.data[0] != '\\0')",
      "            {",
      "                // printf(\"\\n[+]Resending Frame %d\\n\", i);",
      "            }",
      "            else",
      "            {",
      "                frames[i % N].frame_kind = 1;",
      "                frames[i % N].sq_no = i;",
      "",
      "                bytes_read = fread(buffer, 1, MAX_BUFFER_SIZE, file);",
      "",
      "                if (bytes_read == 0)",
      "                {",
      "                    // printf(\"\\n[+]File Read Complete\\n\");",
      "                    strcpy(frames[i % N].packet.data, \"EOF\");",
      "                }",
      "                else if (bytes_read < 0)",
      "                {",
      "                    perror(\"Error reading file\");",
      "                    exit(EXIT_FAILURE);",
      "                }",
      "                else",
      "                    strcpy(frames[i % N].packet.data, buffer);",
      "",
      "                // printf(\"[+]Sending Frame %d\\n\", i);",
      "            }",
      "",
      "            double random_number = (double)rand() / RAND_MAX;",
      "",
      "            // if ((count + 1) % N_lost)",
      "            if (random_number <= P)",
      "            {",
      "                sendto(sockfd, &frames[i % N], sizeof(Frame), 0, (struct sockaddr *)&serverAddress, server_addr_size);",
      "                // printf(\"[+]Frame %d Sent\\n\", i);",
      "            }",
      "            count++;",
      "        }",
      "",
      "        next = start + N;",
      "",
      "        while (1)",
      "        {",
      "            fd_set readfds;",
      "            FD_ZERO(&readfds);",
      "            FD_SET(sockfd, &readfds);",
      "",
      "            struct timeval timeout;",
      "            timeout.tv_sec = TIMEOUT_SEC;",
      "            timeout.tv_usec = TIMEOUT_USEC;",
      "",
      "            int select_result = select(sockfd + 1, &readfds, NULL, NULL, &timeout);",
      "",
      "            if (select_result == -1)",
      "            {",
      "                perror(\"\\nSelect Failed\");",
      "                exit(EXIT_FAILURE);",
      "            }",
      "            else if (select_result == 0)",
      "            {",
      "                // printf(\"\\n[-]Timeout: Ack %d Not Received\\n\", start);",
      "                next = start;",
      "                break;",
      "            }",
      "            else",
      "            {",
      "                if (FD_ISSET(sockfd, &readfds))",
      "                {",
      "                    int recv_size = recvfrom(sockfd, &frame_recv, sizeof(frame_recv), 0, (struct sockaddr *)&serverAddress, &server_addr_size);",
      "",
      "                    if (recv_size < 0)",
      "                    {",
      "                        perror(\"\\nRecvfrom Failed\");",
      "                        exit(EXIT_FAILURE);",
      "                    }",
      "                    else if (recv_size > 0)",
      "                    {",
      "                        if (frame_recv.frame_kind == 0)",
      "                        {",
      "                            // printf(\"\\n[+]Ack %d Received\\n\", frame_recv.sq_no);",
      "",
      "                            if (frame_recv.sq_no >= start)",
      "                            {",
      "                                for (int j = start; j <= frame_recv.sq_no; j++)",
      "                                {",
      "                                    frames[j % N].packet.data[0] = '\\0';",
      "                                }",
      "",
      "                                start = frame_recv.sq_no + 1;",
      "                                break;",
      "                            }",
      "                            else",
      "                            {",
      "                                next = start;",
      "                            }",
      "                        }",
      "                        else if (frame_recv.frame_kind == 1)",
      "                        {",
      "                            // printf(\"\\n[-]Why is Server sending Data Frame???\\n\");",
      "                        }",
      "                        else",
      "                        {",
      "                            // printf(\"\\n[-]Invalid Frame Received\\n\");",
      "                        }",
      "                    }",
      "                    else",
      "                    {",
      "                        // printf(\"\\n[-]Connection Closed\\n\");",
      "                        break;",
      "                    }",
      "                }",
      "            }",
      "        }",
      "",
      "        if (start >= total_frames)",
      "        {",
      "            break;",
      "        }",
      "",
      "        // printf(\"\\n\");",
      "    }",
      "",
      "    fclose(file);",
      "    close(sockfd);",
      "",
      "    gettimeofday(&end_time, NULL);",
      "",
      "    long seconds = end_time.tv_sec - start_time.tv_sec;",
      "    long microseconds = end_time.tv_usec - start_time.tv_usec;",
      "    if (microseconds < 0)",
      "    {",
      "        seconds--;",
      "        microseconds += 1000000;",
      "    }",
      "    // //printf(\"Total time taken: %ld seconds and %ld microseconds\\n\", seconds, microseconds);",
      "    double final_time = seconds * 1000000.0 + microseconds;",
      "    printf(\"%d,%lf\\n\", N, final_time);",
      "    return 0;",
      "}",
      "",
      "int main()",
      "{",
      "    int Ns[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
      "    for (int i = 0; i < sizeof(Ns) / sizeof(int); i++)",
      "    {",
      "        // ////printf(\"\\n[+]N = %lf\\n\", Ns[i]);",
      "        func(Ns[i]);",
      "        // ////printf(\"\\n\\n\");",
      "    }",
      "}"
    ],
    "description": "Go Back N client select"
  },
  "Ack client select": {
    "prefix": "ackcs",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdbool.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <sys/time.h>",
      "#include <sys/select.h>",
      "#include \"../utils.h\"",
      "",
      "#define PORT 8080",
      "#define MAX_BUFFER_SIZE 1024",
      "#define IP \"127.0.0.1\"",
      "#define TIMEOUT_SEC 5  // Timeout in seconds",
      "#define TIMEOUT_USEC 0 // Timeout in microseconds",
      "// #define N_lost 3       // Every N_lost Data frame will be lost",
      "// #define P 1.0                 // Probability with which Data frame will be lost",
      "#define FILENAME \"sample.txt\" // Name of the file to be sent",
      "",
      "int func(double P)",
      "{",
      "    srand(time(NULL));",
      "",
      "    int sockfd;",
      "    struct sockaddr_in serverAddress;",
      "    char buffer[MAX_BUFFER_SIZE];",
      "    socklen_t server_addr_size;",
      "",
      "    FILE *file;",
      "    ssize_t bytes_read;",
      "",
      "    file = fopen(FILENAME, \"rb\");",
      "    if (file == NULL)",
      "    {",
      "        perror(\"Error opening file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    int frame_id = 0;",
      "    Frame frame_send;",
      "    Frame frame_recv;",
      "    bool ack_recv = true;",
      "",
      "    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)",
      "    {",
      "        perror(\"Socket creation failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    memset(&serverAddress, '\\0', sizeof(serverAddress));",
      "    serverAddress.sin_family = AF_INET;",
      "    serverAddress.sin_port = htons(PORT);",
      "    // serverAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\");",
      "    if (inet_pton(AF_INET, IP, &(serverAddress.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    server_addr_size = sizeof(serverAddress);",
      "",
      "    struct timeval start_time, end_time;",
      "    gettimeofday(&start_time, NULL);",
      "",
      "    while (1)",
      "    {",
      "        if (ack_recv == true)",
      "        {",
      "            frame_send.frame_kind = 1;",
      "            frame_send.sq_no = frame_id;",
      "",
      "            bytes_read = fread(buffer, 1, MAX_BUFFER_SIZE, file);",
      "",
      "            if (bytes_read == 0)",
      "            {",
      "                printf(\"\\n[+]File Read Complete\\n\");",
      "                strcpy(frame_send.packet.data, \"EOF\");",
      "            }",
      "            else if (bytes_read < 0)",
      "            {",
      "                perror(\"Error reading file\");",
      "                exit(EXIT_FAILURE);",
      "            }",
      "            else",
      "                strcpy(frame_send.packet.data, buffer);",
      "",
      "            double random_number = (double)rand() / RAND_MAX;",
      "",
      "            // if ((frame_id + 1) % N_lost)",
      "            if (random_number <= P)",
      "            {",
      "                sendto(sockfd, &frame_send, sizeof(Frame), 0, (struct sockaddr *)&serverAddress, server_addr_size);",
      "                printf(\"[+]Frame Sent\\n\");",
      "            }",
      "        }",
      "",
      "        fd_set readfds;",
      "        FD_ZERO(&readfds);",
      "        FD_SET(sockfd, &readfds);",
      "",
      "        struct timeval timeout;",
      "        timeout.tv_sec = TIMEOUT_SEC;",
      "        timeout.tv_usec = TIMEOUT_USEC;",
      "",
      "        int select_result = select(sockfd + 1, &readfds, NULL, NULL, &timeout);",
      "",
      "        if (select_result == -1)",
      "        {",
      "            perror(\"Select Failed\");",
      "            exit(EXIT_FAILURE);",
      "        }",
      "        else if (select_result == 0)",
      "        {",
      "            printf(\"[-]Timeout: Ack Not Received\\n\");",
      "            ack_recv = false;",
      "            sendto(sockfd, &frame_send, sizeof(Frame), 0, (struct sockaddr *)&serverAddress, server_addr_size);",
      "            printf(\"[+]Frame Resent\\n\");",
      "        }",
      "        else",
      "        {",
      "            if (FD_ISSET(sockfd, &readfds))",
      "            {",
      "                int recv_size = recvfrom(sockfd, &frame_recv, sizeof(frame_recv), 0, (struct sockaddr *)&serverAddress, &server_addr_size);",
      "",
      "                if (recv_size < 0)",
      "                {",
      "                    perror(\"Recvfrom Failed\");",
      "                    exit(EXIT_FAILURE);",
      "                }",
      "                else if (recv_size > 0)",
      "                {",
      "                    if (frame_recv.frame_kind == 0 && frame_recv.sq_no == frame_id)",
      "                    {",
      "                        printf(\"[+]Ack Received\\n\");",
      "                        ack_recv = true;",
      "                        frame_id++;",
      "                        if (bytes_read == 0)",
      "                            break;",
      "                    }",
      "                    else if (frame_recv.frame_kind == 0 && frame_recv.sq_no < frame_id)",
      "                    {",
      "                        printf(\"[-]Duplicate Ack Received\\n\");",
      "                        ack_recv = false;",
      "                    }",
      "                    else if (frame_recv.frame_kind == 1)",
      "                    {",
      "                        printf(\"[-]Why is Server sending Data Frame???\\n\");",
      "                    }",
      "                    else",
      "                    {",
      "                        printf(\"[-]Invalid Frame Received\\n\");",
      "                    }",
      "                }",
      "                else",
      "                {",
      "                    printf(\"[-]Connection Closed\\n\");",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "        printf(\"\\n\\n\");",
      "    }",
      "",
      "    fclose(file);",
      "    close(sockfd);",
      "",
      "    gettimeofday(&end_time, NULL);",
      "",
      "    long seconds = end_time.tv_sec - start_time.tv_sec;",
      "    long microseconds = end_time.tv_usec - start_time.tv_usec;",
      "    if (microseconds < 0)",
      "    {",
      "        seconds--;",
      "        microseconds += 1000000;",
      "    }",
      "    // printf(\"Total time taken: %ld seconds and %ld microseconds\\n\", seconds, microseconds);",
      "    // get time in miliseconds",
      "    double final_time = seconds + microseconds / 1000000.0;",
      "    printf(\"%lf,%lf\\n\", 1 - P, final_time);",
      "",
      "    return 0;",
      "}",
      "",
      "int main()",
      "{",
      "    double p_values[] = {1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1};",
      "    for (int i = 0; i < sizeof(p_values) / sizeof(int); i++)",
      "    {",
      "        // printf(\"\\n[+]P = %lf\\n\", p_values[i]);",
      "        func(p_values[i]);",
      "        // printf(\"\\n\\n\");",
      "    }",
      "}",
      ""
    ],
    "description": "Ack client select"
  },
  "Ack server": {
    "prefix": "acks",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <time.h>",
      "#include <stdbool.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include \"../utils.h\"",
      "",
      "#define PORT 8080",
      "#define MAX_BUFFER_SIZE 1024",
      "#define IP \"127.0.0.1\"",
      "#define TIMEOUT 5",
      "// #define N_lost 2 // Every N_lost Acknowledgement frame will be lost",
      "// #define N_delayed 4 // Every N_delayed Acknowledgement Frame will be delayed",
      "#define P 1.0                        // Probability with which Acknowledgement frame will be lost",
      "#define FILENAME \"received_file.txt\" // Name of the file to save on the server",
      "",
      "int main()",
      "{",
      "    srand(time(NULL));",
      "",
      "    int sockfd;",
      "    struct sockaddr_in serverAddress, clientAddress;",
      "    char buffer[MAX_BUFFER_SIZE];",
      "    socklen_t client_addr_size;",
      "",
      "    FILE *file;",
      "    ssize_t bytes_received;",
      "",
      "    file = fopen(FILENAME, \"wb\");",
      "    if (file == NULL)",
      "    {",
      "        perror(\"Error creating file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    int frame_id = 0;",
      "    Frame frame_recv;",
      "    Frame frame_send;",
      "    bool comp = false;",
      "",
      "    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)",
      "    {",
      "        perror(\"socket creation failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    memset(&serverAddress, '\\0', sizeof(serverAddress));",
      "    serverAddress.sin_family = AF_INET;",
      "    serverAddress.sin_port = htons(PORT);",
      "    // serverAddress.sin_addr.s_addr = inet_addr(\"127.0.0.1\");",
      "    if (inet_pton(AF_INET, IP, &(serverAddress.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    if (bind(sockfd, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) < 0)",
      "    {",
      "        perror(\"Error binding socket\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    printf(\"[+]Server Started\\n\\n\");",
      "",
      "    client_addr_size = sizeof(clientAddress);",
      "",
      "    while (1)",
      "    {",
      "        bytes_received = recvfrom(sockfd, &frame_recv, sizeof(Frame), 0, (struct sockaddr *)&clientAddress, &client_addr_size);",
      "",
      "        if (bytes_received < 0)",
      "        {",
      "            printf(\"[-]Error Receiving Frame\\n\");",
      "            exit(EXIT_FAILURE);",
      "        }",
      "        else if (bytes_received > 0)",
      "        {",
      "            if (frame_recv.frame_kind == 1 && frame_recv.sq_no == frame_id)",
      "            {",
      "                printf(\"[+]Frame Received:\\n\");",
      "",
      "                if (frame_recv.packet.data[0] == 'E' && frame_recv.packet.data[1] == 'O' && frame_recv.packet.data[2] == 'F')",
      "                {",
      "                    printf(\"\\n[+]File Transfer Complete\\n\");",
      "                    comp = true;",
      "                }",
      "                else if (fwrite(frame_recv.packet.data, 1, MAX_BUFFER_SIZE, file) != MAX_BUFFER_SIZE)",
      "                {",
      "                    perror(\"Error writing to file\");",
      "                    exit(EXIT_FAILURE);",
      "                }",
      "",
      "                frame_send.frame_kind = 0;",
      "                frame_send.sq_no = frame_id;",
      "",
      "                double random_number = (double)rand() / RAND_MAX;",
      "",
      "                // if ((frame_id + 1) % N_delayed == 0)",
      "                //     sleep(TIMEOUT + 1);",
      "",
      "                if (random_number <= P)",
      "                // if ((frame_id + 1) % N_lost)",
      "                {",
      "                    sendto(sockfd, &frame_send, sizeof(Frame), 0, (struct sockaddr *)&clientAddress, client_addr_size);",
      "                    printf(\"[+]Ack Send\\n\");",
      "                }",
      "",
      "                if (comp)",
      "                {",
      "                    frame_id = 0;",
      "                    comp = false;",
      "                }",
      "                else",
      "                    frame_id++;",
      "            }",
      "            else if (frame_recv.frame_kind == 1 && frame_recv.sq_no < frame_id)",
      "            {",
      "                printf(\"[-]Duplicate Frame Received\\n\");",
      "",
      "                frame_send.frame_kind = 0;",
      "                frame_send.sq_no = frame_id - 1;",
      "",
      "                sendto(sockfd, &frame_send, sizeof(Frame), 0, (struct sockaddr *)&clientAddress, client_addr_size);",
      "                printf(\"[+]Ack Send\\n\");",
      "            }",
      "            else if (frame_recv.frame_kind == 0)",
      "            {",
      "                printf(\"[-]Why is Client sending Acknowledgement Frame???\\n\");",
      "            }",
      "            else",
      "            {",
      "                printf(\"[-]Invalid Frame Received\\n\");",
      "            }",
      "        }",
      "        else",
      "        {",
      "            printf(\"[-]Connection Closed!\\n\");",
      "            break;",
      "        }",
      "        printf(\"\\n\\n\");",
      "    }",
      "",
      "    fclose(file);",
      "    close(sockfd);",
      "    return 0;",
      "}"
    ],
    "description": "Ack server"
  },
  "Go back N client poll": {
    "prefix": "gbncp",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <stdbool.h>",
      "#include <unistd.h>",
      "#include <math.h>",
      "#include <arpa/inet.h>",
      "#include <sys/socket.h>",
      "#include <sys/time.h>",
      "#include <poll.h>",
      "#include \"../utils.h\"",
      "",
      "#define PORT 8080",
      "#define MAX_BUFFER_SIZE 1024",
      "// #define N 3 // Sender Window Size",
      "#define IP \"127.0.0.1\"",
      "#define TIMEOUT_SEC 3  // Timeout in seconds",
      "#define TIMEOUT_USEC 0 // Timeout in microseconds",
      "// #define N_lost 5       // Every N_lost Data frame will be lost",
      "#define P 1.0                 // Probability with which Data frame will be lost",
      "#define FILENAME \"sample.txt\" // Name of the file to be sent",
      "",
      "int func(int N)",
      "{",
      "    srand(time(NULL));",
      "",
      "    int sockfd;",
      "    struct sockaddr_in serverAddress;",
      "    char buffer[MAX_BUFFER_SIZE];",
      "    socklen_t server_addr_size;",
      "",
      "    FILE *file;",
      "    ssize_t bytes_read;",
      "",
      "    file = fopen(FILENAME, \"rb\");",
      "    if (file == NULL)",
      "    {",
      "        perror(\"Error opening file\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    int start = 0;",
      "    int next = start;",
      "    int count = 0;",
      "    Frame frame_recv;",
      "    Frame frames[N];",
      "",
      "    for (int i = 0; i < N; i++)",
      "    {",
      "        frames[i].packet.data[0] = '\\0';",
      "    }",
      "",
      "    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)",
      "    {",
      "        perror(\"socket creation failed\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    memset(&serverAddress, '\\0', sizeof(serverAddress));",
      "    serverAddress.sin_family = AF_INET;",
      "    serverAddress.sin_port = htons(PORT);",
      "    if (inet_pton(AF_INET, IP, &(serverAddress.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    server_addr_size = sizeof(serverAddress);",
      "",
      "    fseek(file, 0, SEEK_END);",
      "    int total_frames = (int)((double)ftell(file) / (double)MAX_BUFFER_SIZE) + ftell(file) % MAX_BUFFER_SIZE ? 2 : 1;",
      "    fseek(file, 0, SEEK_SET);",
      "",
      "    struct timeval start_time, end_time;",
      "    gettimeofday(&start_time, NULL);",
      "",
      "    while (1)",
      "    {",
      "        for (int i = next; i < start + N && start < total_frames; i++)",
      "        {",
      "            if (frames[i % N].packet.data[0] != '\\0')",
      "            {",
      "                // printf(\"\\n[+]Resending Frame %d\\n\", i);",
      "            }",
      "            else",
      "            {",
      "                frames[i % N].frame_kind = 1;",
      "                frames[i % N].sq_no = i;",
      "",
      "                bytes_read = fread(buffer, 1, MAX_BUFFER_SIZE, file);",
      "",
      "                if (bytes_read == 0)",
      "                {",
      "                    // printf(\"\\n[+]File Read Complete\\n\");",
      "                    strcpy(frames[i % N].packet.data, \"EOF\");",
      "                }",
      "                else if (bytes_read < 0)",
      "                {",
      "                    perror(\"Error reading file\");",
      "                    exit(EXIT_FAILURE);",
      "                }",
      "                else",
      "                    strcpy(frames[i % N].packet.data, buffer);",
      "",
      "                // printf(\"[+]Sending Frame %d\\n\", i);",
      "            }",
      "",
      "            double random_number = (double)rand() / RAND_MAX;",
      "",
      "            // if ((count + 1) % N_lost)",
      "            if (random_number <= P)",
      "            {",
      "                sendto(sockfd, &frames[i % N], sizeof(Frame), 0, (struct sockaddr *)&serverAddress, server_addr_size);",
      "                // printf(\"[+]Frame %d Sent\\n\", i);",
      "            }",
      "            count++;",
      "        }",
      "",
      "        next = start + N;",
      "",
      "        struct pollfd poll_fd;",
      "        poll_fd.fd = sockfd;",
      "        poll_fd.events = POLLIN;",
      "",
      "        int poll_result = poll(&poll_fd, 1, TIMEOUT_SEC * 1000); // Convert timeout to milliseconds",
      "",
      "        if (poll_result == -1)",
      "        {",
      "            perror(\"\\nPoll Failed\");",
      "            exit(EXIT_FAILURE);",
      "        }",
      "        else if (poll_result == 0)",
      "        {",
      "            // printf(\"\\n[-]Timeout: Ack %d Not Received\\n\", start);",
      "            next = start;",
      "        }",
      "        else",
      "        {",
      "            if (poll_fd.revents & POLLIN)",
      "            {",
      "                int recv_size = recvfrom(sockfd, &frame_recv, sizeof(frame_recv), 0, (struct sockaddr *)&serverAddress, &server_addr_size);",
      "",
      "                if (recv_size < 0)",
      "                {",
      "                    perror(\"\\nRecvfrom Failed\");",
      "                    exit(EXIT_FAILURE);",
      "                }",
      "                else if (recv_size > 0)",
      "                {",
      "                    if (frame_recv.frame_kind == 0)",
      "                    {",
      "                        // printf(\"\\n[+]Ack %d Received\\n\", frame_recv.sq_no);",
      "",
      "                        if (frame_recv.sq_no >= start)",
      "                        {",
      "                            for (int j = start; j <= frame_recv.sq_no; j++)",
      "                            {",
      "                                frames[j % N].packet.data[0] = '\\0';",
      "                            }",
      "",
      "                            start = frame_recv.sq_no + 1;",
      "                        }",
      "                        else",
      "                        {",
      "                            next = start;",
      "                        }",
      "                    }",
      "                    else if (frame_recv.frame_kind == 1)",
      "                    {",
      "                        // printf(\"\\n[-]Why is Server sending Data Frame???\\n\");",
      "                    }",
      "                    else",
      "                    {",
      "                        // printf(\"\\n[-]Invalid Frame Received\\n\");",
      "                    }",
      "                }",
      "                else",
      "                {",
      "                    // printf(\"\\n[-]Connection Closed\\n\");",
      "                    break;",
      "                }",
      "            }",
      "        }",
      "",
      "        if (start >= total_frames)",
      "        {",
      "            break;",
      "        }",
      "",
      "        // printf(\"\\n\");",
      "    }",
      "",
      "    fclose(file);",
      "    close(sockfd);",
      "",
      "    gettimeofday(&end_time, NULL);",
      "",
      "    long seconds = end_time.tv_sec - start_time.tv_sec;",
      "    long microseconds = end_time.tv_usec - start_time.tv_usec;",
      "    if (microseconds < 0)",
      "    {",
      "        seconds--;",
      "        microseconds += 1000000;",
      "    }",
      "    // //printf(\"Total time taken: %ld seconds and %ld microseconds\\n\", seconds, microseconds);",
      "    double final_time = seconds * 1000000.0 + microseconds;",
      "    printf(\"%d,%lf\\n\", N, final_time);",
      "    return 0;",
      "}",
      "",
      "int main()",
      "{",
      "    int Ns[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};",
      "    for (int i = 0; i < sizeof(Ns) / sizeof(int); i++)",
      "    {",
      "        // //printf(\"\\n[+]N = %lf\\n\", Ns[i]);",
      "        func(Ns[i]);",
      "        // //printf(\"\\n\\n\");",
      "    }",
      "}",
      ""
    ],
    "description": "Go back N client poll"
  },
  "Postfix Evaluator Thread Server1": {
    "prefix": "pest",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "#include <pthread.h>",
      "",
      "#include \"postfix_evaluator.h\"",
      "",
      "#define PORT 8080",
      "#define MAX_PENDING_CONNECTIONS 5",
      "#define MAX_BUFFER_SIZE 1024",
      "#define IP \"10.10.88.233\"",
      "",
      "void *handle_client(void *arg)",
      "{",
      "    int client_socket = *((int *)arg);",
      "    free(arg); // Free memory allocated for the argument",
      "",
      "    char buffer[MAX_BUFFER_SIZE];",
      "    ssize_t bytes_received;",
      "",
      "    // Receive expression from client",
      "    bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);",
      "    if (bytes_received < 0)",
      "    {",
      "        perror(\"Error receiving data from client\");",
      "        close(client_socket);",
      "        pthread_exit(NULL);",
      "    }",
      "    else if (bytes_received == 0)",
      "    {",
      "        // Connection closed by client",
      "        close(client_socket);",
      "        pthread_exit(NULL);",
      "    }",
      "",
      "    buffer[bytes_received] = '\\0';",
      "    // Evaluate expression",
      "    int errorCode = 0;                  // Initialize errorCode to 0",
      "    char errorMessage[MAX_BUFFER_SIZE]; // Initialize errorMessage buffer",
      "    double result = evaluatePostfix(buffer, &errorCode, errorMessage);",
      "    printf(\"Result %lf\\n\", result);",
      "    printf(\"Error Code %d\\n\", errorCode);",
      "    if (errorCode == 0)",
      "    {",
      "        // Send result to client",
      "        char result_str[MAX_BUFFER_SIZE];",
      "        int result_length = snprintf(result_str, sizeof(result_str), \"%lf\", result);",
      "        if (result_length < 0 || result_length >= sizeof(result_str))",
      "        {",
      "            perror(\"Error formatting result\");",
      "        }",
      "        if (send(client_socket, result_str, strlen(result_str), 0) < 0)",
      "        {",
      "            perror(\"Error sending result to client\");",
      "            close(client_socket);",
      "            pthread_exit(NULL);",
      "        }",
      "    }",
      "    else",
      "    {",
      "        if (send(client_socket, errorMessage, strlen(errorMessage), 0) < 0)",
      "        {",
      "            perror(\"Error sending result to client\");",
      "            close(client_socket);",
      "            pthread_exit(NULL);",
      "        }",
      "    }",
      "",
      "    close(client_socket);",
      "    pthread_exit(NULL);",
      "}",
      "",
      "int main()",
      "{",
      "    int server_socket, client_socket;",
      "    struct sockaddr_in server_addr, client_addr;",
      "    socklen_t client_addr_len = sizeof(client_addr);",
      "",
      "    // Create socket",
      "    server_socket = socket(AF_INET, SOCK_STREAM, 0);",
      "    if (server_socket == -1)",
      "    {",
      "        perror(\"Error creating socket\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Set up server address",
      "    server_addr.sin_family = AF_INET;",
      "",
      "    if (inet_pton(AF_INET, IP, &(server_addr.sin_addr)) <= 0)",
      "    {",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    server_addr.sin_port = htons(PORT);",
      "",
      "    // Bind socket to address",
      "    if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)",
      "    {",
      "        perror(\"Couldn't bind socket to address\");",
      "        close(server_socket);",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Listen for incoming connections",
      "    if (listen(server_socket, MAX_PENDING_CONNECTIONS) < 0)",
      "    {",
      "        perror(\"Error listening for connections\");",
      "        close(server_socket);",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    while (1)",
      "    {",
      "        // Accept connection from client",
      "        client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_len);",
      "        if (client_socket < 0)",
      "        {",
      "            perror(\"Error accepting connection\");",
      "            continue;",
      "        }",
      "",
      "        // Create thread to handle client request",
      "        pthread_t tid;",
      "        int *client_socket_ptr = (int *)malloc(sizeof(int));",
      "        if (client_socket_ptr == NULL)",
      "        {",
      "            perror(\"Error allocating memory\");",
      "            close(client_socket);",
      "            continue;",
      "        }",
      "        *client_socket_ptr = client_socket;",
      "        if (pthread_create(&tid, NULL, handle_client, (void *)client_socket_ptr) != 0)",
      "        {",
      "            perror(\"Error creating thread\");",
      "            close(client_socket);",
      "            free(client_socket_ptr);",
      "            continue;",
      "        }",
      "",
      "        // Detach thread",
      "        pthread_detach(tid);",
      "    }",
      "",
      "    close(server_socket);",
      "    return 0;",
      "}",
      ""
    ],
    "description": "Postfix Evaluator Thread Server1"
  },
  "Postfix Evaluator Thread Client": {
    "prefix": "pec",
    "body": [
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <string.h>",
      "#include <unistd.h>",
      "#include <arpa/inet.h>",
      "",
      "#define PORT 8080",
      "#define IP \"10.10.88.233\"",
      "",
      "void send_expression(const char *expression)",
      "{",
      "    int client_socket;",
      "    struct sockaddr_in server_addr;",
      "    char buffer[1024];",
      "",
      "    // Create socket",
      "    client_socket = socket(AF_INET, SOCK_STREAM, 0);",
      "    if (client_socket == -1)",
      "        exit(EXIT_FAILURE);",
      "",
      "    // Set up server address",
      "    server_addr.sin_family = AF_INET;",
      "",
      "    if (inet_pton(AF_INET, IP, &(server_addr.sin_addr)) <= 0)",
      "    {",
      "        // handle_error(\"Invalid address\");",
      "        perror(\"Invalid address\");",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    server_addr.sin_port = htons(PORT);",
      "",
      "    // Connect to server",
      "    if (connect(client_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0)",
      "    {",
      "        close(client_socket);",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Send expression to server",
      "    if (send(client_socket, expression, strlen(expression), 0) < 0)",
      "    {",
      "        close(client_socket);",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    // Receive result from server",
      "    ssize_t bytes_received = recv(client_socket, buffer, sizeof(buffer), 0);",
      "    if (bytes_received < 0)",
      "    {",
      "        close(client_socket);",
      "        exit(EXIT_FAILURE);",
      "    }",
      "",
      "    buffer[bytes_received] = '\\0';",
      "    printf(\"Result from server: %s\\n\", buffer);",
      "",
      "    close(client_socket);",
      "}",
      "",
      "int main()",
      "{",
      "    char expression[1024];",
      "",
      "    printf(\"Enter the postfix expression: \");",
      "    fgets(expression, sizeof(expression), stdin);",
      "    expression[strcspn(expression, \"\\n\")] = '\\0'; // Remove newline character",
      "",
      "    send_expression(expression);",
      "",
      "    return 0;",
      "}",
      ""
    ],
    "description": "Postfix Evaluator Thread Client"
  }
}
